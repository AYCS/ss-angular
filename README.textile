h1. Approach

Create an angular service that can be injected into controllers similar to the angular REST resource library.

h1. Installing

* Create a new socketstream app
* Edit its package.json to add @ss-angular@ as a dependency:

<pre>
"dependencies": {
  "socketstream": "0.3.x",
  "ss-angular": "0.x.x"
}
</pre>

* run @npm install@
* Reference the ss-angular request responder in your app.js:

<pre>
ss.responders.add(require('ss-angular'));
</pre>

This will install the backend request responder, and inject the client library for models specifically and some other wrappers around existing SocketStream features for use in AngularJS.

Add the following to your @client/code/app/entry.js@ above the @ss.server.on@ line

<pre>
require('ssAngular');
require('/controllers');
</pre>

Then define your angular controllres in @client/code/app/controllers.js@

You also have to make sure that you have angular.js in your @client/code/lib@

h1. Running Example

If you clone this repo, there is an example.  To run it, just cd to the example dir and run @npm install@

h1. Model

This is the real value of this library.  If you declare a model in @server/model@, ss-angular will poll it every @pollFreq@ seconds and push deltas to the client.  This is a read-only mechanism.  In the near future, updates will be incremental, but as of version 0.4, it just pushes the entire object on each update whether it has changed or not.  

It's implemented as a request responder, and it is similar to SocketStream's rpc library.  It supports middleware in the same manner as rpc as well.

h2. Server

Define a model in the @server/model@ directory. I called this one example.js:

<pre>
<code class="javascript">
//des describes the model and has the middleware
//chan is a channel on which to post the updated model object

var names = ['Tom','Dick','Harry'];

exports.make = function(des,chan,ss) {
  //des.use if middleware required
  
  return {
    //must have a poll function for now. may have other update models
    poll: function(where) { //where is a JSON where clause
      var obj = {
        hasBall: names[Math.floor(Math.random()*3-0.001)],
        leadingBy: Math.floor(Math.random()*100),
        serverTime: Date.now(),
        filter: where //silly
      };
      chan(obj);
    }
  };
};
</code>
</pre>

h2. Client

This library does expose a raw ss API called @linkModel@ and @unlinkModel@.  You just pass it the model name and parameters and it passes you back an object every N seconds.  From the ss-angular client library:

<pre>
<code class="javascript">
ss.linkModel(name, params, function(modelObj) {
    scope[name] = modelObj;
});
</code>
</pre>

But it's much more fun if you use it via angular! I've exposed a new API in the ssAngular module, and you can use it in angular controllers like this: 

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,model) {
    $scope.linkModel('example',{id: 1234}); //this creates $scope.example and updates it with data in the example model filtered by id 1234
  });
</code>
</pre>

It's that simple.  You define your app's module, the ssAngular dependency and then inject model into your controller's dependencies.  In this case, example is the name of the file I created in @server/model@ and it will be the name of the model on angular's $scope. Here's the html that uses this controller:


<pre>
<code class="html">
<table>
  <thead>
    <tr>
      <th>Has Ball</th>
      <th>Leading By</th>
      <th>Server Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{{example.hasBall}}</td>
      <td>{{example.leadingBy}}</td>
      <td>{{example.serverTime}}</td>
    </tr>
  </tbody>
</table>

</code>
</pre>

The data in curly brackets will be automatically updated.  The link is created by simply mentioning example in the @linkModel@ command.

Important note: you can only subscribe to a named model once in a given scope, even if you use a different where clause.  The idea here is that scopes are fairly narrow, and I'd prefer to refer to the model data without the where clause for simplicity.  If I allow multiple subscriptions to the same model with different where clauses in the same scope, then I have to make you refer to the model by @name/where@ and that's ugly in the HTML.  Just create a lot of scopes and keep your model context broad enough that it "fills" a scope.

One important note: you should @$scope.unlinkModel@ when your scope is destroyed.

h1. Pub Sub

Once you have injected this module into your app and the pubsub service into your scope, you can simply create subscriptions to scope events using angular's API, and if they are prefixed with ss-, this library will subscribe for events from scoket stream with the same name.  When socketstream pushes events, they will be wrapped into Angular scope events on the appropriate scope. 

This method allows you to target the events to the right part of your app and to keep in an "angular" mindset while gaining from socketstream. 

See the example app.  The controller looks like this: 

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,pubsub) {
    $scope.messages = []
      $scope.$on('ss-example', function(event,msg) {
        $scope.messages.push(msg);
      });
    });
</code>
</pre>

h1. RPC

This is handled with the promise API in angular ($q).  You just assign a rpc call to a $scope object, and the value will be assigned when the rpc returns and the GUI updated.  You don't use a callback.  For example:

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,pubsub,rpc) {
    $scope.streaming = false;
    $scope.status = "";

    $scope.toggleData = function() {
      if(!$scope.streaming) {
        $scope.streaming = true;
        $scope.status = rpc('example.on');
      }
      else {
        $scope.streaming = false;
        $scope.status = rpc('example.off', 'Too random');
      }
    };
  });
</code>
</pre>

Here we're assigning the return value of the socketstream services we've defined to $scope.status directly. As you can see, you can pass params or not, but you can't define a callback.  If you really need a callback, just call socketstream directly!


h1. License

ss-angular is released under the MIT license.
