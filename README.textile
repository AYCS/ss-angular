h1. Approach

Create an angular service that can be injected into controllers similar to the angular REST resource library.

h1. Running Example

* cd to the example dir and run @npm install@
* make sure the symlink in example/client/code/lib to the library is working. on windows, i had to fix it after pulling.

h1. Pub Sub

Once you have injected this module into your app and the pubsub service into your scope, you can simply create subscriptions to scope events using angular's API, and if they are prefixed with ss-, this library will subscribe for events from scoket stream with the same name.  When socketstream pushes events, they will be wrapped into Angular scope events on the appropriate scope. 

This method allows you to target the events to the right part of your app and to keep in an "angular" mindset while gaining from socketstream. 

See the example app.  The controller looks like this: 

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,pubsub) {
    $scope.messages = []
      $scope.$on('ss-example', function(event,msg) {
        $scope.messages.push(msg);
      });
    });
</code>
</pre>

h1. RPC

This is handled with the promise API in angular ($q).  You just assign a rpc call to a $scope object, and the value will be assigned when the rpc returns and the GUI updated.  You don't use a callback.  For example:

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,pubsub,rpc) {
    $scope.streaming = false;
    $scope.status = "";

    $scope.toggleData = function() {
      if(!$scope.streaming) {
        $scope.streaming = true;
        $scope.status = rpc('example.on');
      }
      else {
        $scope.streaming = false;
        $scope.status = rpc('example.off', 'Too random');
      }
    };
  });
</code>
</pre>

Here we're assigning the return value of the socketstream services we've defined to $scope.status directly. As you can see, you can pass params or not, but you can't define a callback.  If you really need a callback, just call socketstream directly!

h1. Model

Creates a read only model.  A model in this context is a complex object that is updated by the server and communicated to the client.  The data is communicated incrementally via a pubsub channel after a snapshot is delivered on the rpc channel.  There is always a sequence number on the model so if a diff is received out of order, it is held until gaps are filled and then applied in order.  The goal is to synchronize a potentially very large model between client and server without retransmitting the whole object each time a single field changes.

h2. Why is it read only?  

The main reason is that it's not necessary for my application!  Changes can be applied to the server orthogonally via RPC for my problem domain.  Also, there are other libraries out there for a two way synched model (Racer of Derby fame and ShareJS), and I'm not trying to reimplement them.  That said, I can envision a methodology where diffs are sent to server, applied and retransmitted back to the client.  
