h1. Approach

Create an angular service that can be injected into controllers similar to the angular REST resource library.

h1. Running Example

* cd to the example dir and run @npm install@
* make sure the symlink in example/client/code/lib to the library is working. on windows, i had to fix it after pulling.

h1. Pub Sub

Once you have injected this module into your app and the pubsub service into your scope, you can simply create subscriptions to scope events using angular's API, and if they are prefixed with ss-, this library will subscribe for events from scoket stream with the same name.  When socketstream pushes events, they will be wrapped into Angular scope events on the appropriate scope. 

This method allows you to target the events to the right part of your app and to keep in an "angular" mindset while gaining from socketstream. 

See the example app.  The controller looks like this: 

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,pubsub) {
    $scope.messages = []
      $scope.$on('ss-example', function(event,msg) {
        $scope.messages.push(msg);
      });
    });
</code>
</pre>

h1. RPC

This is handled with the promise API in angular ($q).  You just assign a rpc call to a $scope object, and the value will be assigned when the rpc returns and the GUI updated.  You don't use a callback.  For example:

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,pubsub,rpc) {
    $scope.streaming = false;
    $scope.status = "";

    $scope.toggleData = function() {
      if(!$scope.streaming) {
        $scope.streaming = true;
        $scope.status = rpc('example.on');
      }
      else {
        $scope.streaming = false;
        $scope.status = rpc('example.off', 'Too random');
      }
    };
  });
</code>
</pre>

Here we're assigning the return value of the socketstream services we've defined to $scope.status directly. As you can see, you can pass params or not, but you can't define a callback.  If you really need a callback, just call socketstream directly!

h1. Model

Creates a read only model.  A model in this context is a complex object that is updated by the server and communicated to the client.  The data is communicated incrementally via a pubsub channel after a snapshot is delivered on the rpc channel.  There is always a sequence number on the model so if a diff is received out of order, it is held until gaps are filled and then applied in order.  The goal is to synchronize a potentially very large model between client and server without retransmitting the whole object each time a single field changes.

h2. Protocol Details

h3. Server

h4. Model Class

* name
** String that will be matched with against a client request
* query
** Currently fairly coupled to MongoDB due to my problem domain.
* pollingFreq
* baselineID
** UUID for each poll to DB
* listeners
** map: (offset,subscriber)[baselineID]
** offset: number of updates since a given baseline. Increases monotonically and only when there is a diff 
** subscriber: function that takes care of delivering update
** This can potentially be maintained in a middleware
* content
** The object that is diffed against query results

h4. Server Algorithm

h5. Event Loop

# Query database every _pollingFreq_ seconds
# Diff results against _content_ to create a delta
# Apply the delta to the baseline
** Probably do this as the delta is being created rather than a separate step
# Iterate through listeners
# For each that exists, increment _seqNum_ and notify of the update on _subscriber_ channel

h5. Request Process

# Client requests baseline via RPC
# Confirmation is delivered through RPC channel
# Baseline is delivered via pubsub channel called @ss-model-modelName@
** JSON string
# Deltas come through the same pubsub channel
** JSON string
** Putting both baseline and deltas through same pubsub channel ensures synchronization
# Each delta will include its baseline and offset

h3. Client

h4. Model Class

* name
* baselineID
* seqNum
* content

h4. Client Algorithm

# Subscribe for model updates on a pubsub channel
** Most likely a session channel
# Request data for that model via RPC
# Await baseline
# As deltas come in, modify the baseline

h5. Self Healing

# Any time a baseline comes in from the server, take it and destroy old content and baselineID
# If a seqNum is out of order, request a new baseline

h2. Why is it read only?  

The main reason is that it's not necessary for my application!  Changes can be applied to the server orthogonally via RPC for my problem domain.  Also, there are other libraries out there for a two way synched model (Racer of Derby fame and ShareJS), and I'm not trying to reimplement them.  That said, I can envision a methodology where diffs are sent to server, applied and retransmitted back to the client.  
