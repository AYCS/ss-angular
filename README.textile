h1. Approach

Create an angular service that can be injected into controllers similar to the angular REST resource library.

h1. Installing

* Create a new socketstream app
* Edit its package.json to add @ss-angular@ as a dependency:

<pre>
"dependencies": {
  "socketstream": "0.3.x",
  "ss-angular": "0.x.x"
}
</pre>

* run @npm install@
* Reference the ss-angular request responder in your app.js:

<pre>
ss.responders.add(require('ss-angular'));
</pre>

This will install the backend request responder, and inject the client library for models specifically and some other wrappers around existing SocketStream features for use in AngularJS.

h1. Running Example

If you clone this repo, there is an example.  To run it, just cd to the example dir and run @npm install@

h1. Pub Sub

Once you have injected this module into your app and the pubsub service into your scope, you can simply create subscriptions to scope events using angular's API, and if they are prefixed with ss-, this library will subscribe for events from scoket stream with the same name.  When socketstream pushes events, they will be wrapped into Angular scope events on the appropriate scope. 

This method allows you to target the events to the right part of your app and to keep in an "angular" mindset while gaining from socketstream. 

See the example app.  The controller looks like this: 

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,pubsub) {
    $scope.messages = []
      $scope.$on('ss-example', function(event,msg) {
        $scope.messages.push(msg);
      });
    });
</code>
</pre>

h1. RPC

This is handled with the promise API in angular ($q).  You just assign a rpc call to a $scope object, and the value will be assigned when the rpc returns and the GUI updated.  You don't use a callback.  For example:

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,pubsub,rpc) {
    $scope.streaming = false;
    $scope.status = "";

    $scope.toggleData = function() {
      if(!$scope.streaming) {
        $scope.streaming = true;
        $scope.status = rpc('example.on');
      }
      else {
        $scope.streaming = false;
        $scope.status = rpc('example.off', 'Too random');
      }
    };
  });
</code>
</pre>

Here we're assigning the return value of the socketstream services we've defined to $scope.status directly. As you can see, you can pass params or not, but you can't define a callback.  If you really need a callback, just call socketstream directly!

h1. Model

This is the real value of this library.  If you declare a model in @server/model@, ss-angular will poll it every @pollFreq@ seconds and push deltas to the client.  This is a read-only mechanism.  In the near future, updates will be incremental, but as of version 0.4, it just pushes the entire object on each update whether it has changed or not.  

It's implemented as a request responder, and it is similar to SocketStream's rpc library.  It supports middleware in the same manner as rpc as well.


h2. Server

Define a model in the @server/model@ directory. I called this one example.js:

<pre>
<code class="javascript">
//des describes the model and has the middleware
//chan is a channel on which to post the updated model object

var names = ['Tom','Dick','Harry'];

exports.make = function(des,chan,ss) {
  //des.use if middleware required
  
  return {
    //must have a poll function for now. may have other update models
    poll: function() {
      var obj = {
        hasBall: names[Math.floor(Math.random()*3-0.001)],
        leadingBy: Math.floor(Math.random()*100),
        serverTime: Date.now()
      };
      chan(obj);
    }
  };
};
</code>
</pre>

h2. Client

This library does expose a raw ss API called @linkModel@.  You just pass it the model name and it passes you back and object ever N seconds.  From the ss-angular client library:


<pre>
<code class="javascript">
ss.linkModel(name, function(modelObj) {
    scope[name] = modelObj;
});
</code>
</pre>

But it's much more fun if you use it via angular! I've exposed a new API in the ssAngular module, and you can use it in angular controllers like this: 

<pre>
<code class="javascript">
angular.module('exampleApp', ['ssAngular'])
  .controller('SSCtrl',function($scope,syncModel) {
    syncModel('example'); //this creates $scope.example and updates it
  });
</code>
</pre>

It's that simple.  You define your app's module, the ssAngular dependency and then inject syncModel into your controller's dependencies.  In this case, example is the name of the file I created in @server/model@ and it will be the name of the model on angular's $scope. Here's the html that uses this controller:



<pre>
<code class="html">
<table>
  <thead>
    <tr>
      <th>Has Ball</th>
      <th>Leading By</th>
      <th>Server Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>{{example.hasBall}}</td>
      <td>{{example.leadingBy}}</td>
      <td>{{example.serverTime}}</td>
    </tr>
  </tbody>
</table>

</code>
</pre>

The data in curly brackets will be automatically updated.  The link is created by simply mentioning example in the @syncModel@ command.
